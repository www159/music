## 工具选择
想要集成多个音乐端，剔除冗余的`音乐社交`功能。
考虑全平台，以后大概率自己使用,加上学习rust,使用tauri

## 抽象层次
tauri处于一个尴尬的位置

- 前端对渲染的抽象没有`带chromium`的渲染器高
- 后端对系统接口的抽象没有`带vm`的语言高

但是也处于一个比较舒适的位置

- IE已死，前端适配工作大大减少
- 使用`内存安全`的语言对后端实现了一定层次的抽象(`自己使用unsafe另当别论`...吗？)，以及相对c高级一点的宏实现了`带vm`语言的一些特性(`编译过慢的元凶`)

## 效率
前端是否需要浏览器的渲染引擎?人的感知远没有自己想象的那么精确，GUI简单的逻辑并不会占用过多的资源。因此无论用什么都一个样。**真正的速度瓶颈往往在网路请求和硬盘IO上**。换作10年前的win7时代，ssd没有普及，哪怕是c实现的也得卡顿。

## 展望
希望chatGPT能带领Microsoft的chromium完成前端大一统

希望云上桌面成为主流，云原生app完成后端的大一统

希望大神设计一款高效的rust vm让后端HMR不再是梦

## 技术分析
### tauri通信
tauri使用三种方式进行前后端交互分别是http,rpc,消息订阅

- 前端 -> 后端: http, rpc, 消息订阅
- 后端 -> 前端: 消息订阅

其中tauri的大多数原生功能都使用了http封装，比如窗口的尺寸，最小化状态等等

其中消息订阅最为灵活，我还年轻，驾驭不了，因此使用简单的rpc就行

（说不定rpc底层用的还是http或消息订阅？）

### 过程宏
tuari 的rpc过程宏`#[tauri::command]`隐藏了三个可选参数，类型分别是`tauri::Window`, `tauri::State`和`tauri::AppHandler`。

### react相关
react里可以说的太多了，基本上是这么一套组合拳:
- hint
- UI库
- i18n
- 全局状态管理
- 样式语言
- 路由
- url请求
- 第三方组件
    - ....
- *css in js*

搞完这些身体已经被榨干了